Several times throughout the previous lesson, we've mentioned that services can be combined. This is also called composition. A service is composed when it is made up of other services. Composition is the action of coordinating several services and providing an interface. Service composition can occur at several levels. A service that is composed of other lower-level services may itself be used to compose higher-level services. This is similar to the composing objects principle in object oriented design, which tells us that code reuse can be achieved by aggregation. However, web services are not usually compiled and run in the same physical location. Instead, composing services involves invoking services in a certain order and handling exceptions that may arise. The services that comprise a composite service still remain separate from that service. In a sense, a composite service could be like a script that uses the other services according to some pre-determined order as we can see in this UML sequence diagram. Of course, which requests are made to a service or which service is called may depend on the response from another service. This is better captured on a UML activity diagram like in this next example. The composite service uses other services. In this case, the composite service selects a different service based on the response it gets back from the first. Before web services Middleware solutions were more difficult to compose because their interfaces were not standardized. And so, wrappers had to be developed as needed to make components interface with each other or with the Middleware. Web services can easily be composed because they are accessed in similar ways. In this module, services are invoked with SOAP messages described by WSDL and cataloged by UDDI. The newer standards can and have in many cases superseded this particular collection of standards. Web services are, by their nature, built to use web standards and are easier to compose and coordinate the Middleware solutions. However, the problem that comes with combining services don't go away with web services. They're simply a bit easier to manage. You may notice in the last example that composing a service from other services looked a lot like a business process. Such processes are easily mapped to activity diagrams. The beginning and end of the process are the points at which the composite service is exposed to service requesters. In other words, it's interface. The rounded boxes represent services and arrows represent the order of service interactions. The goal of a standard for composing services is to not work with low-level programmatic details but to be able to combine services at a higher-level. The lower-level interaction between services is already covered by the standards we've already discussed. Business Process Execution Language or BPEL is the standard high-level composition language for web services. It's also called WS-BPEL to align it with other standard parts of the web service stack we've been discussing. With BPEL, developers can compose compatible services into a business process that is itself exposed as a service. Like all of the web services we've been talking about, these can be from external sources out on the Internet or internal to a company or other private organization. This example uses both internal and external services. Let's say you are a car manufacturer and you have a remote warehouse. In this case, each swim lane represents a service. Your part order service is a composite service. When you make a request for a part, it first queries the warehouse service. This query will return the number of that part in stock. If the number is more than zero then the part order service request the said part and returns a confirmation to the part order service, which also sends a confirmation to its service requester. If the number zero, then the part order service uses a different service from your warehouse requesting the latest price for the part in question. The external supplier returns a price for the part order service and the part order service returns that to its service requester. Obviously, this example is fairly trivial but the point remains people allows developers to create new services by composing them with existing services. It supports basic operations like the IF, THEN, ELSE decision in the example, and other logic through various program languages and wrappers. In our examples, we called the process of combining services Composition. There's another idea you may come across if you're studying web services called coordination. This is when a process coordinates the activities of two or more services. The distinguishing feature of Composition as opposed to coordination is that it exposes the collection of actions as another service. Composing services is like composing objects in object-oriented design. It allows you to build new functionality by combining existing functionality and encapsulate the new functionality as a service. Basic services often have low-level basic functionality. This functionality can be combined into a higher-level of functionality with WS-BPEL and exposed as a service which can in turn be composed into higher-level services. WS-BPEL is the language for putting these building blocks together in a high-level fashion. This leaves the lower-level details of inter-service communication to the protocols we've already talked about like SOAP and WSDL. If you work with SOAP-based web services keep WS-BPEL in mind if you need to create new services out of existing services. As well, you can use UML sequence and activity diagrams to model how services need to be coordinated.